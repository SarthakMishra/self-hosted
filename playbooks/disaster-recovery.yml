---
# Disaster Recovery Playbook
# Restores complete infrastructure from local Restic backup repository

- name: Disaster Recovery from Local Backups
  hosts: all
  become: true
  gather_facts: true
  
  vars:
    local_backup_repository: "{{ local_restic_repository | default('/path/to/local-backup-sync/data/local-repository') }}"
    recovery_target: "{{ recovery_target_path | default('/') }}"
    recovery_snapshot: "{{ target_snapshot | default('latest') }}"
    safety_mode: "{{ safety_checkpoint | default(true) }}"
    
  pre_tasks:
    - name: Determine connection method for disaster recovery
      ansible.builtin.set_fact:
        ansible_host: "{{ base_host if disaster_recovery_use_ip | default(false) else (tailscale_hostname | default(inventory_hostname)) }}"
      when: base_host is defined
      tags: always

    - name: Display disaster recovery banner
      ansible.builtin.debug:
        msg:
          - "=================================================="
          - "ðŸš¨ DISASTER RECOVERY OPERATION"
          - "=================================================="
          - ""
          - "Target: {{ inventory_hostname }} ({{ ansible_default_ipv4.address }})"
          - "Recovery Source: {{ local_backup_repository }}"
          - "Target Path: {{ recovery_target }}"
          - "Snapshot: {{ recovery_snapshot }}"
          - ""
          - "âš ï¸  WARNING: This will overwrite existing data!"
          - "ðŸ”„ Complete system restoration in progress"
          - ""
      tags: always

    - name: Safety checkpoint
      ansible.builtin.pause:
        prompt: |
          
          ðŸš¨ DISASTER RECOVERY SAFETY CHECKPOINT ðŸš¨
          
          This operation will restore data from local backups to {{ inventory_hostname }}
          
          Source Repository: {{ local_backup_repository }}
          Target Directory: {{ recovery_target }}
          Snapshot ID: {{ recovery_snapshot }}
          
          This will OVERWRITE existing data on the target system!
          
          Type 'yes' to proceed or 'no' to cancel
      register: safety_confirmation
      when: safety_mode | bool
      tags: always

    - name: Validate safety confirmation
      ansible.builtin.fail:
        msg: "Disaster recovery cancelled by user"
      when: 
        - safety_mode | bool
        - safety_confirmation.user_input | lower != 'yes'
      tags: always

    - name: Verify local backup repository access
      ansible.builtin.stat:
        path: "{{ local_backup_repository }}"
      delegate_to: localhost
      register: local_repo_check
      tags: always

    - name: Fail if local repository not accessible
      ansible.builtin.fail:
        msg: "Local backup repository not found at {{ local_backup_repository }}"
      when: not local_repo_check.stat.exists
      tags: always

  tasks:
    - name: Install Restic for recovery operations
      ansible.builtin.package:
        name: restic
        state: present
      tags: [recovery, install]

    - name: Create temporary recovery directory
      ansible.builtin.tempfile:
        state: directory
        suffix: -disaster-recovery
      register: temp_recovery_dir
      tags: [recovery, prepare]

    - name: Copy Restic repository to target server
      ansible.builtin.synchronize:
        src: "{{ local_backup_repository }}/"
        dest: "{{ temp_recovery_dir.path }}/repository/"
        compress: true
        delete: false
      tags: [recovery, sync]

    - name: Copy Restic password file
      ansible.builtin.copy:
        src: "{{ local_backup_repository }}/../config/restic-password"
        dest: "{{ temp_recovery_dir.path }}/restic-password"
        mode: '0600'
      tags: [recovery, prepare]

    - name: Set Restic environment variables
      ansible.builtin.set_fact:
        restic_env:
          RESTIC_REPOSITORY: "{{ temp_recovery_dir.path }}/repository"
          RESTIC_PASSWORD_FILE: "{{ temp_recovery_dir.path }}/restic-password"
      tags: [recovery, prepare]

    - name: Verify repository integrity
      ansible.builtin.command:
        cmd: restic check --read-data-subset=5%
      environment: "{{ restic_env }}"
      register: repo_check_result
      tags: [recovery, verify]

    - name: List available snapshots
      ansible.builtin.command:
        cmd: restic snapshots --compact
      environment: "{{ restic_env }}"
      register: snapshots_list
      tags: [recovery, verify]

    - name: Display available snapshots
      ansible.builtin.debug:
        msg: "{{ snapshots_list.stdout_lines }}"
      tags: [recovery, verify]

    - name: Get snapshot ID for recovery
      ansible.builtin.command:
        cmd: restic snapshots --latest 1 --json
      environment: "{{ restic_env }}"
      register: latest_snapshot
      when: recovery_snapshot == 'latest'
      tags: [recovery, prepare]

    - name: Set recovery snapshot ID
      ansible.builtin.set_fact:
        recovery_snapshot_id: "{{ (latest_snapshot.stdout | from_json)[0].id if recovery_snapshot == 'latest' else recovery_snapshot }}"
      tags: [recovery, prepare]

    - name: Display recovery information
      ansible.builtin.debug:
        msg:
          - "Recovery Snapshot ID: {{ recovery_snapshot_id }}"
          - "Target Path: {{ recovery_target }}"
          - "Repository Check: {{ repo_check_result.rc == 0 | ternary('PASSED', 'FAILED') }}"
      tags: [recovery, prepare]

    - name: Stop Docker services before recovery
      ansible.builtin.systemd:
        name: docker
        state: stopped
      ignore_errors: true
      tags: [recovery, stop-services]

    - name: Stop other services that might interfere
      ansible.builtin.systemd:
        name: "{{ item }}"
        state: stopped
      loop:
        - tailscaled
        - restic-backup.timer
        - restic-maintenance.timer
      ignore_errors: true
      tags: [recovery, stop-services]

    - name: Perform disaster recovery restore
      ansible.builtin.command:
        cmd: >
          restic restore {{ recovery_snapshot_id }}
          --target {{ recovery_target }}
          --verify
      environment: "{{ restic_env }}"
      register: restore_result
      tags: [recovery, restore]

    - name: Display restore results
      ansible.builtin.debug:
        msg:
          - "Restore completed with exit code: {{ restore_result.rc }}"
          - "Files restored to: {{ recovery_target }}"
          - ""
          - "Restore output:"
          - "{{ restore_result.stdout_lines }}"
      tags: [recovery, restore]

    - name: Fix file permissions after restore
      ansible.builtin.file:
        path: "{{ item.path }}"
        mode: "{{ item.mode }}"
        owner: "{{ item.owner | default('root') }}"
        group: "{{ item.group | default('root') }}"
        recurse: "{{ item.recurse | default(false) }}"
      loop:
        - { path: "/opt/docker-swarm", mode: "0755", recurse: true }
        - { path: "/etc/docker", mode: "0755", recurse: true }
        - { path: "/var/lib/docker", mode: "0755", owner: "root", group: "root", recurse: true }
        - { path: "/home/admin/.ssh", mode: "0700", owner: "admin", group: "admin" }
        - { path: "/home/admin/.ssh/authorized_keys", mode: "0600", owner: "admin", group: "admin" }
      when: recovery_target == "/"
      ignore_errors: true
      tags: [recovery, permissions]

    - name: Restart essential services
      ansible.builtin.systemd:
        name: "{{ item }}"
        state: started
        daemon_reload: true
      loop:
        - tailscaled
        - docker
      ignore_errors: true
      tags: [recovery, restart-services]

    - name: Wait for Docker to be ready
      ansible.builtin.wait_for:
        port: 2376
        host: localhost
        timeout: 60
      ignore_errors: true
      tags: [recovery, restart-services]

    - name: Re-initialize Docker Swarm if needed
      ansible.builtin.command:
        cmd: docker swarm init --force-new-cluster
      when: 
        - recovery_target == "/"
        - node_type in ['single', 'manager']
      ignore_errors: true
      tags: [recovery, docker-swarm]

    - name: Restart backup services
      ansible.builtin.systemd:
        name: "{{ item }}"
        state: started
        enabled: true
      loop:
        - restic-backup.timer
        - restic-maintenance.timer
      ignore_errors: true
      tags: [recovery, restart-services]

  post_tasks:
    - name: Cleanup temporary files
      ansible.builtin.file:
        path: "{{ temp_recovery_dir.path }}"
        state: absent
      tags: [recovery, cleanup]

    - name: Display disaster recovery completion
      ansible.builtin.debug:
        msg:
          - "================================================================"
          - "ðŸŽ‰ DISASTER RECOVERY COMPLETED!"
          - "================================================================"
          - ""
          - "âœ… System restored from local backup repository"
          - "âœ… Snapshot ID: {{ recovery_snapshot_id }}"
          - "âœ… Target: {{ recovery_target }}"
          - "âœ… Essential services restarted"
          - ""
          - "ðŸ”„ Next Steps:"
          - "  1. Verify Docker Swarm status: docker node ls"
          - "  2. Check service health: docker service ls"
          - "  3. Validate application functionality"
          - "  4. Resume normal backup operations"
          - "  5. Update DNS/network configurations if needed"
          - ""
          - "ðŸ“‹ Validation Commands:"
          - "  - systemctl status docker"
          - "  - docker info"
          - "  - tailscale status"
          - "  - systemctl status restic-backup.timer"
          - ""
          - "ðŸŽ¯ DISASTER RECOVERY SUCCESSFUL!"
          - ""
      tags: always 