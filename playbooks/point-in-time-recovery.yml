---
# Point-in-Time Recovery Playbook
# Restores specific services or data to a particular point in time from local backups

- name: Point-in-Time Recovery from Local Backups
  hosts: all
  become: true
  gather_facts: true
  
  vars:
    # Backup source configuration
    backup_source: "{{ recovery_source | default('auto') }}"  # auto, remote, local
    remote_backup_repository: "{{ remote_restic_repository | default('/opt/docker-swarm/backup/repository') }}"
    local_backup_repository: "{{ local_restic_repository | default('/path/to/local-backup-sync/data/local-repository') }}"
    
    # Recovery configuration  
    recovery_target: "{{ recovery_target_path | default('/tmp/recovery') }}"
    target_timestamp: "{{ recovery_timestamp | mandatory }}"  # ISO format: 2024-01-15T10:30:00
    service_name: "{{ recovery_service | default('') }}"
    include_patterns: "{{ recovery_include | default([]) }}"
    exclude_patterns: "{{ recovery_exclude | default([]) }}"
    
    # Connection settings for remote backup access
    remote_host: "{{ recovery_remote_host | default(inventory_hostname) }}"
    remote_user: "{{ recovery_remote_user | default('admin') }}"
    
  pre_tasks:
    - name: Display point-in-time recovery banner
      ansible.builtin.debug:
        msg:
          - "=================================================="
          - "‚è∞ POINT-IN-TIME RECOVERY OPERATION"
          - "=================================================="
          - ""
          - "Target: {{ inventory_hostname }} ({{ ansible_default_ipv4.address }})"
          - "Recovery Time: {{ target_timestamp }}"
          - "Service: {{ service_name if service_name else 'All Services' }}"
          - "Recovery Target: {{ recovery_target }}"
          - "Backup Source: {{ backup_source }} (auto=try remote first, fallback to local)"
          - ""
          - "üîç Determining backup source and finding closest snapshot"
          - ""
      tags: always

    - name: Verify local backup repository access
      ansible.builtin.stat:
        path: "{{ local_backup_repository }}"
      delegate_to: localhost
      register: local_repo_check
      tags: always

    - name: Fail if local repository not accessible
      ansible.builtin.fail:
        msg: "Local backup repository not found at {{ local_backup_repository }}"
      when: not local_repo_check.stat.exists
      tags: always

    - name: Validate timestamp format
      ansible.builtin.fail:
        msg: "Invalid timestamp format. Use ISO format: YYYY-MM-DDTHH:MM:SS"
      when: not (target_timestamp | regex_search('^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}$'))
      tags: always

    - name: Validate backup source parameter
      ansible.builtin.fail:
        msg: "Invalid backup_source. Must be one of: auto, remote, local"
      when: backup_source not in ['auto', 'remote', 'local']
      tags: always

  tasks:
    - name: Install required packages
      ansible.builtin.package:
        name:
          - restic
          - jq
        state: present
      tags: [recovery, install]

    # Backup Source Determination
    - name: Test remote backup repository availability
      block:
        - name: Check if remote repository is accessible
          ansible.builtin.stat:
            path: "{{ remote_backup_repository }}/config"
          register: remote_repo_check
          when: backup_source in ['auto', 'remote']

        - name: Test remote repository integrity
          ansible.builtin.command:
            cmd: restic check --no-cache
          environment:
            RESTIC_REPOSITORY: "{{ remote_backup_repository }}"
            RESTIC_PASSWORD_FILE: "/opt/docker-swarm/backup/restic-password"
          register: remote_repo_integrity
          failed_when: false
          when: 
            - backup_source in ['auto', 'remote']
            - remote_repo_check.stat.exists | default(false)

        - name: Set remote backup availability
          ansible.builtin.set_fact:
            remote_backup_available: "{{ (remote_repo_check.stat.exists | default(false)) and (remote_repo_integrity.rc | default(1) == 0) }}"
          when: backup_source in ['auto', 'remote']

        - name: Set remote backup availability to false for local-only mode
          ansible.builtin.set_fact:
            remote_backup_available: false
          when: backup_source == 'local'

      tags: [recovery, source-detection]

    - name: Determine actual backup source to use
      ansible.builtin.set_fact:
        actual_backup_source: >-
          {%- if backup_source == 'local' -%}
            local
          {%- elif backup_source == 'remote' -%}
            {%- if remote_backup_available | default(false) -%}
              remote
            {%- else -%}
              failed
            {%- endif -%}
          {%- elif backup_source == 'auto' -%}
            {%- if remote_backup_available | default(false) -%}
              remote
            {%- else -%}
              local
            {%- endif -%}
          {%- endif -%}
      tags: [recovery, source-detection]

    - name: Fail if remote backup required but not available
      ansible.builtin.fail:
        msg: |
          Remote backup repository is not available or corrupted.
          Remote repository: {{ remote_backup_repository }}
          You can:
          1. Use local backup: -e recovery_source=local
          2. Use auto fallback: -e recovery_source=auto (default)
          3. Fix remote repository access and try again
      when: actual_backup_source == 'failed'
      tags: [recovery, source-detection]

    - name: Display selected backup source
      ansible.builtin.debug:
        msg:
          - "üìÇ Backup Source Selected: {{ actual_backup_source | upper }}"
          - "{% if actual_backup_source == 'remote' %}üåê Using remote repository: {{ remote_backup_repository }}{% endif %}"
          - "{% if actual_backup_source == 'local' %}üíæ Using local repository: {{ local_backup_repository }}{% endif %}"
          - "{% if backup_source == 'auto' and actual_backup_source == 'local' %}‚ö†Ô∏è  Remote backup not available, falling back to local repository{% endif %}"
      tags: [recovery, source-detection]

    - name: Create temporary recovery directory
      ansible.builtin.tempfile:
        state: directory
        suffix: -point-in-time-recovery
      register: temp_recovery_dir
      tags: [recovery, prepare]

    # Local backup setup (copy repository and password file)
    - name: Setup local backup repository
      block:
        - name: Copy local Restic repository to target server
          ansible.builtin.synchronize:
            src: "{{ local_backup_repository }}/"
            dest: "{{ temp_recovery_dir.path }}/repository/"
            compress: true
            delete: false

        - name: Copy local Restic password file
          ansible.builtin.copy:
            src: "{{ local_backup_repository }}/../config/restic-password"
            dest: "{{ temp_recovery_dir.path }}/restic-password"
            mode: '0600'

        - name: Set Restic environment for local repository
          ansible.builtin.set_fact:
            restic_env:
              RESTIC_REPOSITORY: "{{ temp_recovery_dir.path }}/repository"
              RESTIC_PASSWORD_FILE: "{{ temp_recovery_dir.path }}/restic-password"

      when: actual_backup_source == 'local'
      tags: [recovery, prepare]

    # Remote backup setup (use existing repository directly)
    - name: Setup remote backup repository
      block:
        - name: Set Restic environment for remote repository
          ansible.builtin.set_fact:
            restic_env:
              RESTIC_REPOSITORY: "{{ remote_backup_repository }}"
              RESTIC_PASSWORD_FILE: "/opt/docker-swarm/backup/restic-password"

      when: actual_backup_source == 'remote'
      tags: [recovery, prepare]

    - name: Find snapshots closest to target time
      ansible.builtin.shell: |
        restic snapshots --json | jq -r "
          map(select(.time <= \"{{ target_timestamp }}\")) | 
          sort_by(.time) | 
          last | 
          .id // \"none\"
        "
      environment: "{{ restic_env }}"
      register: closest_snapshot_result
      tags: [recovery, find-snapshot]

    - name: Set closest snapshot ID
      ansible.builtin.set_fact:
        closest_snapshot_id: "{{ closest_snapshot_result.stdout.strip() }}"
      tags: [recovery, find-snapshot]

    - name: Fail if no suitable snapshot found
      ansible.builtin.fail:
        msg: "No snapshot found before {{ target_timestamp }}"
      when: closest_snapshot_id == "none" or closest_snapshot_id == ""
      tags: [recovery, find-snapshot]

    - name: Get snapshot details
      ansible.builtin.shell: |
        restic snapshots --json | jq -r "
          map(select(.id == \"{{ closest_snapshot_id }}\")) | 
          .[0] | 
          {time: .time, hostname: .hostname, tags: .tags}
        "
      environment: "{{ restic_env }}"
      register: snapshot_details_result
      tags: [recovery, find-snapshot]

    - name: Display snapshot information
      ansible.builtin.debug:
        msg:
          - "Selected Snapshot ID: {{ closest_snapshot_id }}"
          - "Snapshot Details: {{ snapshot_details_result.stdout }}"
          - "Recovery will restore data as it was at the time of this snapshot"
      tags: [recovery, find-snapshot]

    - name: Create recovery target directory
      ansible.builtin.file:
        path: "{{ recovery_target }}"
        state: directory
        mode: '0755'
      tags: [recovery, prepare]

    - name: Build restore command
      ansible.builtin.set_fact:
        restore_command: >-
          restic restore {{ closest_snapshot_id }}
          --target {{ recovery_target }}
          --verify
          {% for pattern in include_patterns %}
          --include "{{ pattern }}"
          {% endfor %}
          {% for pattern in exclude_patterns %}
          --exclude "{{ pattern }}"
          {% endfor %}
      tags: [recovery, prepare]

    - name: Display restore command
      ansible.builtin.debug:
        msg: "Restore command: {{ restore_command }}"
      tags: [recovery, prepare]

    - name: Perform point-in-time restore
      ansible.builtin.shell: "{{ restore_command }}"
      environment: "{{ restic_env }}"
      register: restore_result
      tags: [recovery, restore]

    - name: Display restore results
      ansible.builtin.debug:
        msg:
          - "Point-in-time restore completed with exit code: {{ restore_result.rc }}"
          - "Files restored to: {{ recovery_target }}"
          - ""
          - "Restore output:"
          - "{{ restore_result.stdout_lines }}"
      tags: [recovery, restore]

    - name: Create service-specific restore if service specified
      block:
        - name: Stop target service if running
          ansible.builtin.systemd:
            name: "{{ service_name }}"
            state: stopped
          ignore_errors: true
          when: service_name != ""

        - name: Backup current service data
          ansible.builtin.shell: |
            if [ -d "/var/lib/docker/volumes/{{ service_name }}" ]; then
              cp -r "/var/lib/docker/volumes/{{ service_name }}" "/tmp/{{ service_name }}-backup-$(date +%s)"
              echo "Current service data backed up"
            fi
          register: service_backup_result
          when: service_name != ""

        - name: Restore service data from point-in-time backup
          ansible.builtin.shell: |
            if [ -d "{{ recovery_target }}/backup/volumes/{{ service_name }}" ]; then
              rsync -av "{{ recovery_target }}/backup/volumes/{{ service_name }}/" "/var/lib/docker/volumes/{{ service_name }}/"
              echo "Service data restored from point-in-time backup"
            else
              echo "No service data found in backup for {{ service_name }}"
              exit 1
            fi
          register: service_restore_result
          when: service_name != ""

        - name: Restart service with restored data
          ansible.builtin.systemd:
            name: "{{ service_name }}"
            state: started
            daemon_reload: true
          when: 
            - service_name != ""
            - service_restore_result.rc == 0

        - name: Display service restore results
          ansible.builtin.debug:
            msg:
              - "Service {{ service_name }} restoration:"
              - "{{ service_restore_result.stdout_lines }}"
          when: service_name != ""

      tags: [recovery, service-restore]

    - name: Generate recovery report
      ansible.builtin.template:
        src: recovery-report.j2
        dest: "{{ recovery_target }}/RECOVERY-REPORT.txt"
        mode: '0644'
      vars:
        recovery_type: "Point-in-Time"
        recovery_timestamp: "{{ target_timestamp }}"
        snapshot_id: "{{ closest_snapshot_id }}"
        snapshot_details: "{{ snapshot_details_result.stdout }}"
        restore_exit_code: "{{ restore_result.rc }}"
        service_restored: "{{ service_name if service_name else 'N/A' }}"
        backup_source_used: "{{ actual_backup_source }}"
        backup_repository_used: "{{ restic_env.RESTIC_REPOSITORY }}"
      tags: [recovery, report]

  post_tasks:
    - name: Cleanup temporary files
      ansible.builtin.file:
        path: "{{ temp_recovery_dir.path }}"
        state: absent
      when: actual_backup_source == 'local'  # Only cleanup if we copied local repository
      tags: [recovery, cleanup]

    - name: Display point-in-time recovery completion
      ansible.builtin.debug:
        msg:
          - "================================================================"
          - "‚è∞ POINT-IN-TIME RECOVERY COMPLETED!"
          - "================================================================"
          - ""
          - "‚úÖ Data restored to: {{ recovery_target }}"
          - "‚úÖ Recovery time: {{ target_timestamp }}"
          - "‚úÖ Snapshot ID: {{ closest_snapshot_id }}"
          - "‚úÖ Backup source: {{ actual_backup_source | upper }}"
          - "{% if actual_backup_source == 'remote' %}üì° Used remote repository: {{ remote_backup_repository }}{% endif %}"
          - "{% if actual_backup_source == 'local' %}üíæ Used local repository: {{ local_backup_repository }}{% endif %}"
          - "{% if service_name %}‚úÖ Service {{ service_name }} restored and restarted{% endif %}"
          - ""
          - "üìÅ Recovery Location: {{ recovery_target }}"
          - "üìã Recovery Report: {{ recovery_target }}/RECOVERY-REPORT.txt"
          - ""
          - "üîç Next Steps:"
          - "  1. Review restored data in {{ recovery_target }}"
          - "  2. Compare with current system state"
          - "  3. Apply changes as needed"
          - "{% if service_name %}  4. Verify {{ service_name }} functionality{% endif %}"
          - "  5. Clean up recovery directory when done"
          - ""
          - "üéØ POINT-IN-TIME RECOVERY SUCCESSFUL!"
          - ""
      tags: always 